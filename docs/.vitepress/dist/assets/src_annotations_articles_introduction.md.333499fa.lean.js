import{_ as e,v as a,b as n,R as o}from"./chunks/framework.bf5b583c.js";const t="/Java/assets/uml_enquete.3055c2ae.png",g=JSON.parse('{"title":"Introduction","description":"","frontmatter":{"pageClass":"annotations"},"headers":[],"relativePath":"src/annotations/articles/introduction.md","filePath":"src/annotations/articles/introduction.md","lastUpdated":null}'),s={name:"src/annotations/articles/introduction.md"},r=o('<h1 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h1><p>Pour ce mémento on considère une application Web de gestion d’enquêtes dont voici le diagramme de classes métier :</p><p><img src="'+t+'" alt="uml_enquete"></p><p>Les annotations donnent des consignes au programme, au compilateur ou à l’outil qui génère la documentation. Ces consignes sont qualifiées de métadonnées. Elles font leur apparition avec la version 5 du JDK sortie en 2004. À cette époque, dans le package java.lang, elles sont au nombre de quatre et sont encore utilisées aujourd’hui : <code>@Override</code>, <code>@Deprecated</code>, <code>@SuppressWarnings</code> et <code>@SafeVarargs</code> <a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Override.html" target="_blank" rel="noreferrer">https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Override.html</a></p><p>Une annotation est définie par Oracle comme un type spécial d’interface : <a href="https://docs.oracle.com/javase/specs/jls/se18/html/jls-9.html#jls-9.6" target="_blank" rel="noreferrer">https://docs.oracle.com/javase/specs/jls/se18/html/jls-9.html#jls-9.6</a></p><p>Elle se déclare en utilisant l’écriture <code>@interface</code> :</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> @</span><span style="color:#F47067;">interface</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">MonAnnotation</span><span style="color:#ADBAC7;"> {}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> @</span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">MonAnnotation</span><span style="color:#24292E;"> {}</span></span></code></pre></div><p>Avec la version 6 du JDK sortie en 2006, Sun enrichit l’ensemble des annotations en proposant les common annotations (notamment <code>@Resource</code> et <code>@PostConstruct</code>) regroupées dans les package javax.annotation (Java SE) et javax.annotation.security (Java EE).</p><p>Avec la version 8 du JDK sortie en 2014, Oracle ajoute l’annotation <code>@FunctionalInterface</code> dans le package <code>java.lang</code> pour permettre aux développeurs Java de passer à la programmation fonctionnelle.</p><p>On distinguera les annotations dites marqueur (marker annotations) c’est-à-dire sans attribut (exemple : <code>@Override</code>), les annotations paramétrées avec une seule valeur (single value annotations) (exemple : <code>@Max(42)</code>) et les annotations avec plusieurs paramètres (full annotations) (exemple : <code>@Range(min=1, max=42)</code>).</p><p>Chaque framework apporte son lot d’annotations, il en va de même pour les bibliothèques.</p><p>Ce mémento, débuté en 2015, a pour objectif de présenter quelques annotations à connaître dans chaque framework/bibliothèque. Il n’a pas pour objectif d’être exhaustif.</p><p>Pour aller plus loin sur le concept d’annotation, je vous invite à consulter le lien suivant : <a href="https://www.jmdoudoux.fr/java/dej/chap-annotations.htm" target="_blank" rel="noreferrer">https://www.jmdoudoux.fr/java/dej/chap-annotations.htm</a></p>',13),l=[r];function c(i,p,d,u,m,v){return a(),n("div",null,l)}const f=e(s,[["render",c]]);export{g as __pageData,f as default};
